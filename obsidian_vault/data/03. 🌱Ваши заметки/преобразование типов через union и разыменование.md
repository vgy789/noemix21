---
share: true
date: 
tags:
  - note
  - nsk
project: 
s21-authors:
  - "[[ptyrande]]"
branch: "[[C]]"
source: https://21-school-by-students.notion.site/8dd1f9ac4324444ab62fb78fb808981f
title: Преобразование типов через Union и разыменование
---

## Преобразование типов

> Всем привет! В миру я - Камерлох Роман, в Школе и слаке - ptyrande. Почта: [kamerlokh@gmail.com](mailto:kamerlokh@gmail.com)

Немного расскажу о том, **Как преобразовать значение хранящееся в памяти из одного типа в другой** (при условии равенства занимаемой памяти).

Два способа:

1. **через разыменовывание указателя** (увидеть `float` как `int`):

```c
float f = 100.5;
int i = *((int *)&f); 
```

получаем 100.5 в том виде, в котором его хранит float (стандарт **ieee 754**)

2. **через union**.

**union - выделяет память** один раз и **столько, сколько занимает самый большой элемент**.

То есть, **все элементы указывают на один участок памяти**.

пример 1:

```c
union converter_float {    
	float   fl;    
	uint    dw;
};
converter_float.fl = 100.5;
// converter_float.dw - в нём автоматически лежит 100.5 в том виде, в котором 
// его хранит float (стандарт ieee 754)
```

пример 2 (**как лично я делал хранение scale и sign**):

```c
union converter {
	int    number;    
	char   bytes[4];
};
```

для этого union выделено 32 бита памяти.

int number занимает 32 бита;

bytes[4] занимает 32 бита.

Поэтому, присвоив bytes[3] = 128 (**10000000** в битовом виде) мы получаем number = **10000000** _~~00000000 00000000 00000000~~_ (здесь зачеркнутое означает, что присваиванием bytes[3] = 128 мы влияем только на последние (**считается справа налево**) 8 бит, остальные остаются не изменными, то что в них было, то и останется).

обе переменных указывают в **одно и то же место в памяти**.

Далее присваеваем scale: bytes[2] = 2 мы получаем number = ~~10000000~~ **00000010** ~~00000000 00000000~~ (установили scale = 0b10 == 2), здесь так же влияем только на устанавливаемые 8 бит, другие биты не меняются(!)).

