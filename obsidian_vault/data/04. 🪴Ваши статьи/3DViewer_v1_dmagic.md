---
share: true
banner: "[[met_henry_lerolle_1885.jpg]]"
date: 
tags:
  - article
  - nsk
project: "[[C8 3DViewer_v1.0]]"
s21-authors:
  - "[[dmagic]]"
branch: "[[C]]"
title: 3DViewer_v1_dmagic – dmagic
source: https://21-school-by-students.notion.site/3D-Viewer_v1-0-61eefd10077a4b49ac4b8449e640acf9
description: 1. Разбор структуры .obj файла. 2. Выделение необходимых структур. 3. Отрисовка.
---

## Первый раздел – .obj файлы, структура проекта, отрисовка

### 1. Разбор структуры .obj файла

Начнём с базовых вещей и разбора как устроен .obj файл. Тут не будет полного разбора всех возможных определений и значений данных файлов, а лишь то, что необходимо нам для сдачи проекта.

В данном случае это будут строки начинающиеся на **`v`** и содержащие далее 3 числовых значения, представленные в виде числа типа `double`. Это значения вершин объекта. Так как мы рисуем трёхмерные объекты то и вершины у нас 3 - x, y, z.

*Пример:*

```markdown
v 1 1 0
v 1 0 1
v …
```

*Ещё вариант возможной записи:*

```markdown
v 123.123 456.321 -342.85
v 87.32 -75.45 12.32
v …
```

> *Сразу стоить заметить, что для систем Windows необходимо в .obj файле заменить точки на запятые, так как там числа с плавающей точкой записываются через запятую. Так делать стоит в том случае, если для считывания вы будете использовать sscanf. Если вы пишете свой парсер чисел, то оставляйте точки.*

Также нас будут интересовать строки начинающиеся на **`f`**. Эти строки могут содержать от 3 до ∞ значений. Значения могут стоять как по одному, так и по несколько рядом, разделенные знаком /. Но нам нужны  только первые числа этой записи. Значения, записанные после **`f`** будут содержать номера вершин, которые необходимо соединить для получения полигона (*facet*).

*Пример:*

```markdown
f 1 2 3
f 3/1 4/2 5/3
f 6/4/1 3/5/3 7/6/
f 6//1 3//3 7//5
f …
```

Рассмотрим все строки и что из них нам необходимо:

- *1 строка* - “*идеальная*”, в ней нет лишних значений. Эта строка говорит нам о том, что необходимо соединить первую, вторую и третью вершины линиями, для получения полигона;
- *2 строка* - в ней уже присутствуют лишние для нас значения. Тут, как и в предыдущем примере, первые числа, записанные перед **/,** будут содержать номера вершин, что необходимо соединить. Значения после / - это значения текстурных координат (для окрашивания полигона);
- *3 строка* - здесь к значениям вершин и текстурных координат добавляются значения нормали. Значения нормали необходимо для закрашивания нашего полигона;
- *4 строка* - в ней отсутствуют значения текстурных координат, значения вершин и нормали остаются.

Выше описаны полигоны, состоящие из трёх вершин, но важно помнить, что строка, начинающаяся с **`f`,**  может содержать в себе от 3 до ∞ значений вершин, и  их количество может изменяться в зависимости от того, как много вершин нам нужно соединить.

> *Стоит заметить, что нумерация вершин начинается с 1, а не с 0, как мы уже привыкли.*

Таким образом, для нашего задания необходимо отделить значения вершин от остальных значений.

Теперь мы знаем, что нам нужны только значения координат вершин и какие вершины соединять между собой для получения полигона (мы не берём другие значения, так как по заданию нам нужно сделать отрисовку именно каркасной модели, то есть нарисовать вершины и соединить их линиями, закрашивать полученные полигоны нет необходимости).

На этом знакомство с obj файлом для данного проекта можно считать законченным. Далее мы будет приступать к написанию структуры, которая сможет хранить в себе данную модель.

### 2. Выделение необходимых структур

Так как мы не знаем, каких размеров нам будет приходить .obj файл (*ведь он может быть на 8 вершин, а может и на 1кк*), то наша структура будет динамической и выделять столько памяти, сколько необходимо для хранения значений данного файла. Также, из-за того, что мы не можем сразу читать строку и выделять для нее память (*можем конечно, но это будет более затратным решением*), мы будем читать наш файл два раза. Первый раз мы читаем файл и подсчитываем кол-во вершин в файле, соответственно, сразу добавляем в нашу структуру данное поле:

```c
typedef struct data {
	int count_of_vertexes;
	…
}
```

> *Я использую `int` в качестве примера, но мы можем заменить его на `unsigned int`, т.к. кол-во вершин не может быть отрицательным, что позволит нам увеличить кол-во вершин в 2 раза.*

Ещё нам необходимо подсчитать кол-во наших полигонов, это всё ещё делается при первом чтении файла. Занесем и это значение в нашу структуру:

```c
typedef struct data {
	int count_of_vertexes;
	int count_of_facets;
	…
}
```

На этом наш первый проход по файлу завершён и мы можем приступить к подготовке нашей структуры для второго чтения.

Теперь мы знаем кол-во всех вершин и можем для них создать матрицу, где индекс строки будет соответствовать индексу вершины в .obj файле.

> *Тут мы делаем небольшую хитрость:  мы создадим матрицу на 1 размер больше, чем это необходимо. Делается это для того, чтобы вершина, которую мы первую считаем пошла в ряд с номером 1, а не 0, дабы потом избежать путаницы и постоянного отнимания от значений 1 (возможно, не самое оптимальное, но удобное решение).*

Создаем структуру для матрицы:

```c
typedef struct Matrix {
	double **matrix;
	int rows;
	int cols;
} matrix_t;
```

И добавляем эту структуру в нашу основную структуру с данными (*можно, конечно, хранить все структуры отдельно, но я пишу их все вместе дабы было удобнее объяснять*).

Теперь наша структура выглядит следующим образом:

```c
typedef struct data {
	int count_of_vertexes;
	int count_of_facets;
	matrix_t matrix_3d;
	…
}
```

Перейдем к моменту выделения памяти.

Для рядов выделяем память: **count_of_vertexes + 1.** Для колонок выделяем память: **3**, так как у нас всего три координаты, которые мы хотим хранить.

Продолжаем подготавливать нашу структуру, нам нужно придумать способ хранения полигонов. Для этого создадим структуру `polygon_t`:

```c
typedef struct facets {
	…
} polygon_t;
```

В нее добавим массив номеров вершин, которые мы будем хранить для соединений, а также кол-во вершин необходимых для соединения:

```c
typedef struct facets {
	int *vertexes;
	int numbers_of_vertexes_in_facets;
} polygon_t;
```

Добавим эту структуру к себе в основную структуру, но с одним условием, т.к. у нас подразумевается, что полигонов может быть много, мы эту структуру пометим как массив структур, а длина этого массива будет равняться **count_of_facets + 1**.

> *Здесь ‘+ 1’ также для того, чтобы уже вся структура имела счёт с 1.*

```c
typedef struct data {
	int count_of_vertexes;
	int count_of_facets;
	matrix_t matrix_3d;
	polygon_t *polygons;
}
```

Теперь начинаем читать наш файл второй раз.

В структуру matrix_3d записываем вершины. Тут достаточно будет один раз прочитать строку и записать в `matrix_3d.matrix[i][0]`**,** `matrix_3d.matrix[i][1]`**,** `matrix_3d.matrix[i][2]` значения **x y z** соответственно. Где **i** значения от **1** до **count_of_vertexes + 1**.

Для структуры `*polygons`* мы уже выделили необходимо кол-во памяти, но внутри структуры у нас есть массив, для которого мы память не выделяли.

Данный момент стоит разделить на две функции, куда последовательно будут отправляться строка, начинающаяся на **`f`**.

Первая функция необходима для подсчета кол-ва вершин, которые необходимо соединить. Начинаем считывать строку, начинающуюся на  **`f`**. Подсчитываем кол-во вершин и заносим в `polygons[i].numbers_of_vertexes_in_facets`.

Теперь выделяем память для `polygons[i].vertexes`**,** равную `polygons[i].numbers_of_vertexes_in_facets`.

И эту же строку отправляем на запись вершин в массив для которого мы только что выделили память.

На этом чтение файла заканчивается. Теперь у нас есть структура данных, содержащая в себе матрицу всех вершин и массив вершин, что необходимо соединить.

### 3. Отрисовка

Как будет происходить отрисовка:

Сначала расставляем точки на нашей поверхности. Для этого идём по matrix_3d  и выставляем точки в значениях x и y. Данная отрисовка точек будет иметь **параллельную** **проекцию** (вы можете данный пункт пропустить, но он необходим для бонусной части).

Переходим к соединению наших точек.

Для этого запускаем цикл, который будет идти по нашим значениям от **1** до `count_of_facets + 1`. Этот цикл будет проходить нашу структуру `polygons`. В ней мы смотрим, какие вершины соответствуют нашему первому полигону. Далее запускается второй цикл, который будет идти уже по самому массиву вершин для соединения, сопоставлять значения из этого массива с индексами в матрице и вытаскивать значения `x y`, соединяя их.

> *Также не забудьте соединить последнюю и первую точку нашего полигона.*

Стоит добавить, что мы можем создать структуру максимальных и минимальных значения, для создания функции, которая будет масштабировать наш объект при его выводе на экран, потому что одна фигура может лежать в пределах от 1 до 0, и при отрисовке её будет сложно разглядеть, а другой объект может лежать в пределах от 10к до -10к и такой объект может не поместиться полностью в область рисования.

> *По заданию такой функционал не обязателен для нашей программы, достаточно будет сделать обычный scale, который позволит менять масштаб модели, но реализация данного функционала добавит вашей программе “удобности”.*
>
>
> # Второй раздел - аффинные преобразования

Начнём по порядку из **tasklist.**

- ***Загружать каркасную модель из файла формата obj (поддержка только списка вершин и поверхностей).***

Данный пункт мы выполнили, наша структуру позволяет хранить кол-во вершин и полигонов нашего объекта. Нужно будет лишь выводить данную информацию на экран.

- ***Перемещать модель на заданное расстояние относительно осей X, Y, Z.***

Напишу общий пример для всех перемещений:

Идём по матрице значений циклом и к необходимому ряду прибавляем значение, на которое мы хотим переместить фигуру.

*Пример*:

```c
void move_x(matrix_t *A, double a) {
	for (int i = 0; i < A->rows; i++) A->matrix[i][0] += a;
}
```

- ***Поворачивать модель на заданный угол относительно осей X, Y, Z.***

Тут уже придётся самостоятельно изучить такие вещи как матрица поворота. Но я приведу пример для вращения по оси X:

```c
void rotation_by_ox(matrix_t *A, double angle) {
	for (int i = 0; i < A->rows; i++) {
		double temp_y = A->matrix[i][1];
		double temp_z = A->matrix[i][2];
		A->matrix[i][1] = cos(angle) * temp_y - sin(angle) * temp_z;
		A->matrix[i][2] = sin(angle) * temp_y + cos(angle) * temp_z;
	}
}
```

Стоит понимать, что в зависимости от оси вращения мы подставляем разные коэффициенты (*cos/sin -cos/-sin*)

Подробнее можете прочитать здесь: https://grafika.me/node/82

- ***Масштабировать модель на заданное значение.***

Тоже ничего уникального, проходимся по каждому значению в нашей матрице и умножаем его на коэффициент. Стоит заметить, что необходимо заблокировать пользователю возможность умножать на 0, иначе вся структура превратиться в 0 и вы не сможете её восстановить пока не загрузите модель заново.

---

На этом разбор задания можно считать законченным. Думаю бонусную часть оставить для индивидуального решения. Сложности с ней не должно возникнуть. И не забывайте, что всё это - лишь один из возможных вариантов выполнения поставленной задачи, цель которого, помочь вам понять алгоритм решения.

---

### Заключение

- ❗ Придумывайте, творите, пробуйте и ошибайтесь, и успех не заставит себя ждать. На этом всё! Ни бага ни лага!

- 📎 Та же лекция, но на google docs - [*тык*](https://docs.google.com/document/d/1dHcD6B60WW2xMrJmTuLIcsfYzAEfUpeXg6E1-yoUVq4/edit)
